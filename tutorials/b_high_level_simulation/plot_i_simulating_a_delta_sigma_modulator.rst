
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/b_high_level_simulation/plot_i_simulating_a_delta_sigma_modulator.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_tutorials_b_high_level_simulation_plot_i_simulating_a_delta_sigma_modulator.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_b_high_level_simulation_plot_i_simulating_a_delta_sigma_modulator.py:


Simulating a CTSD Modulator
==================================================

.. GENERATED FROM PYTHON SOURCE LINES 5-17

.. code-block:: default

    import cbadc
    import numpy as np
    import matplotlib.pyplot as plt
    import json

    T = 1e-9
    N = 3
    K1 = 1 << 9
    K2 = K1
    OSR = 40
    BW = 1 / (2 * T * OSR)








.. GENERATED FROM PYTHON SOURCE LINES 18-24

Instantiating the Analog System and Digital Control
---------------------------------------------------

We start by loading a delta sigma modulator constructed
using the `www.sigma-delta.de <www.sigma-delta.de>`_ framework.


.. GENERATED FROM PYTHON SOURCE LINES 24-47

.. code-block:: default


    with open('CTSD_N3_OSR40_Q2_CRFB_OPT1_HINF150.json') as f:
        analog_frontend_ctsd = cbadc.synthesis.ctsd_dict2af(json.load(f), T)

    eta2_ctsd = (
        np.linalg.norm(
            analog_frontend_ctsd.analog_system.transfer_function_matrix(
                np.array([2 * np.pi * BW])
            )
        )
        ** 2
    )

    digital_estimator_ctsd = cbadc.digital_estimator.BatchEstimator(
        analog_frontend_ctsd.analog_system,
        analog_frontend_ctsd.digital_control,
        eta2_ctsd,
        K1,
        K2,
    )

    print(analog_frontend_ctsd.analog_system)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    The analog system is parameterized as:
    A =
    [[ 0.00e+00  0.00e+00  0.00e+00]
     [ 3.10e+08  0.00e+00 -1.49e+07]
     [ 0.00e+00  2.49e+08  0.00e+00]],
    B =
    [[ 1.46e+08]
     [ 0.00e+00]
     [ 0.00e+00]],
    CT = 
    [[ 1.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  1.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  1.00e+00]],
    Gamma =
    [[-1.46e+08]
     [-2.46e+08]
     [-1.70e+08]],
    Gamma_tildeT =
    [[ 0.00e+00  0.00e+00  3.94e+00]], and D=[[ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]]




.. GENERATED FROM PYTHON SOURCE LINES 48-51

Leap Frog
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 51-93

.. code-block:: default


    analog_frontend_leap_frog = cbadc.synthesis.get_leap_frog(
        OSR=OSR, N=N, BW=BW, opt=False
    )

    # analog_frontend_leap_frog.digital_control = (
    #     cbadc.digital_control.MultiLevelDigitalControl(
    #         analog_frontend_leap_frog.digital_control.clock, N, [1] * N
    #     )
    # )

    # Scale B
    # analog_frontend_leap_frog.analog_system.B = (
    #     2 * analog_frontend_leap_frog.analog_system.B
    # )


    # Scale Gamma
    # analog_frontend_leap_frog.analog_system.Gamma = np.dot(
    #     np.diag(np.array([0.5 ** (x + 1) for x in range(N)])),
    #     analog_frontend_leap_frog.analog_system.Gamma,
    # )

    eta2_leap_frog = (
        np.linalg.norm(
            analog_frontend_leap_frog.analog_system.transfer_function_matrix(
                np.array([2 * np.pi * BW])
            )
        )
        ** 2
    )

    digital_estimator_leap_frog = cbadc.digital_estimator.BatchEstimator(
        analog_frontend_leap_frog.analog_system,
        analog_frontend_leap_frog.digital_control,
        eta2_leap_frog,
        K1,
        K2,
    )

    print(analog_frontend_leap_frog.analog_system)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    The analog system is parameterized as:
    A =
    [[ 0.00e+00 -3.08e+06  0.00e+00]
     [ 5.00e+08  0.00e+00 -3.08e+06]
     [ 0.00e+00  5.00e+08  0.00e+00]],
    B =
    [[ 5.00e+08]
     [ 0.00e+00]
     [ 0.00e+00]],
    CT = 
    [[ 1.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  1.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  1.00e+00]],
    Gamma =
    [[ 5.00e+08  0.00e+00  0.00e+00]
     [ 0.00e+00  5.00e+08  0.00e+00]
     [ 0.00e+00  0.00e+00  5.00e+08]],
    Gamma_tildeT =
    [[-1.00e+00 -0.00e+00 -0.00e+00]
     [-0.00e+00 -1.00e+00 -0.00e+00]
     [-0.00e+00 -0.00e+00 -1.00e+00]], and D=[[ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]]




.. GENERATED FROM PYTHON SOURCE LINES 94-97

Input Signal
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 97-107

.. code-block:: default

    amplitude = 0.25e-0
    phase = 0.0
    offset = 0.0
    frequency = 1.0 / analog_frontend_ctsd.digital_control.clock.T

    while frequency > BW:
        frequency /= 2
    input_signal = cbadc.analog_signal.Sinusoidal(amplitude, frequency, phase, offset)
    # input_signal = cbadc.analog_signal.ConstantSignal(amplitude)








.. GENERATED FROM PYTHON SOURCE LINES 108-111

Transfer Functions
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 111-176

.. code-block:: default


    # Logspace frequencies
    frequencies = np.logspace(3, 8, 1000)
    omega = 2 * np.pi * frequencies

    # Compute transfer functions for each frequency in frequencies
    transfer_function_ctsd = analog_frontend_ctsd.analog_system.transfer_function_matrix(
        omega
    )
    transfer_function_ctsd_dB = 20 * np.log10(np.abs(transfer_function_ctsd))

    transfer_function_leap_frog = (
        analog_frontend_leap_frog.analog_system.transfer_function_matrix(omega)
    )
    transfer_function_leap_frog_dB = 20 * np.log10(np.abs(transfer_function_leap_frog))

    G_omega = 20 * np.log10(np.linalg.norm(transfer_function_ctsd[:, 0, :], axis=0))

    plt.semilogx([BW, BW], [np.min(G_omega), np.max(G_omega)], '--', label="BW")

    # Add the norm ||G(omega)||_2
    plt.semilogx(
        frequencies,
        20 * np.log10(np.linalg.norm(transfer_function_leap_frog[:, 0, :], axis=0)),
        label="LF $ ||\mathbf{G}(\omega)||_2 $",
    )
    plt.semilogx(
        frequencies,
        G_omega,
        label="CTSD $ ||\mathbf{G}(\omega)||_2 $",
    )


    # Add labels and legends to figure
    plt.legend()
    plt.grid(which="both")
    plt.xlabel("$f$ [Hz]")
    plt.ylabel("dB")
    plt.xlim((frequencies[0], frequencies[-1]))
    plt.gcf().tight_layout()


    for n in range(N):
        plt.figure()
        #     color = next(plt.gca()._get_lines.prop_cycler)["color"]
        plt.semilogx(
            frequencies,
            transfer_function_leap_frog_dB[n, 0, :],
            label="LF $G_" + f"{n+1}" + "(f)$",
            # color = color
        )
        plt.semilogx(
            frequencies,
            transfer_function_ctsd_dB[n, 0, :],
            '--',
            label="CTSD $G_" + f"{n+1}" + "(f)$",
            #     # color = color
        )
        plt.legend()
        plt.grid(which="both")
        plt.xlabel("$f$ [Hz]")
        plt.ylabel("dB")
        plt.xlim((frequencies[0], frequencies[-1]))
        plt.gcf().tight_layout()




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_001.png
         :alt: plot i simulating a delta sigma modulator
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_001.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_002.png
         :alt: plot i simulating a delta sigma modulator
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_002.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_003.png
         :alt: plot i simulating a delta sigma modulator
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_003.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_004.png
         :alt: plot i simulating a delta sigma modulator
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_004.png
         :class: sphx-glr-multi-img





.. GENERATED FROM PYTHON SOURCE LINES 177-180

Simulation Setup
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 180-196

.. code-block:: default


    simulator_ctsd = cbadc.simulator.get_simulator(
        analog_frontend_ctsd.analog_system,
        analog_frontend_ctsd.digital_control,
        [input_signal],
    )
    digital_estimator_ctsd(simulator_ctsd)

    simulator_leap_frog = cbadc.simulator.get_simulator(
        analog_frontend_leap_frog.analog_system,
        analog_frontend_leap_frog.digital_control,
        [input_signal],
    )
    digital_estimator_leap_frog(simulator_leap_frog)









.. GENERATED FROM PYTHON SOURCE LINES 197-200

Simulate State Trajectories
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 200-261

.. code-block:: default


    # Simulate for 65536 control cycles.
    size = 1 << 14

    time_vector = np.arange(size)
    states = np.zeros((N, size, 2))
    control_signals = np.zeros((N, size, 2), dtype=np.double)

    # Iterate through and store states and control_signals.
    simulator_ctsd = cbadc.simulator.extended_simulation_result(simulator_ctsd)
    simulator_leap_frog = cbadc.simulator.extended_simulation_result(simulator_leap_frog)
    for index in cbadc.utilities.show_status(range(size)):
        res_ctsd = next(simulator_ctsd)
        states[:, index, 0] = res_ctsd["analog_state"]
        control_signals[:, index, 0] = res_ctsd["control_signal"]
        res_leap_frog = next(simulator_leap_frog)
        states[:, index, 1] = res_leap_frog["analog_state"]
        control_signals[:, index, 1] = res_leap_frog["control_signal"]

    xlim = 1 << 12
    # Plot all analog state evolutions.
    plt.figure()
    plt.title("Analog state vectors")
    for index in range(N):
        plt.plot(time_vector, states[index, :, 1], label=f"LF $x_{index + 1}(t)$")
        plt.plot(time_vector, states[index, :, 0], label=f"CTSD $x_{index + 1}(t)$")
    plt.grid(visible=True, which="major", color="gray", alpha=0.6, lw=1.5)
    plt.xlabel("$t/T$")
    plt.xlim((0, xlim))
    plt.legend()


    # reset figure size and plot individual results.
    plt.rcParams["figure.figsize"] = [6.40, 6.40 * 2]
    fig, ax = plt.subplots(N, 2)
    for index in range(N):
        color = next(ax[0, 0]._get_lines.prop_cycler)["color"]
        color2 = next(ax[0, 0]._get_lines.prop_cycler)["color"]
        ax[index, 0].grid(visible=True, which="major", color="gray", alpha=0.6, lw=1.5)
        ax[index, 1].grid(visible=True, which="major", color="gray", alpha=0.6, lw=1.5)
        ax[index, 0].plot(time_vector, states[index, :, 1], color=color2, label="LF")
        ax[index, 0].plot(time_vector, states[index, :, 0], color=color, label="CTSD")
        ax[index, 1].plot(
            time_vector, control_signals[0, :, 1], "--", color=color2, label="LF"
        )
        if index == (N - 1):
            ax[index, 1].plot(
                time_vector, control_signals[0, :, 0], "--", color=color, label="CTSD"
            )
        ax[index, 0].set_ylabel(f"$x_{index + 1}(t)$")
        ax[index, 1].set_ylabel(f"$s_{index + 1}(t)$")
        ax[index, 0].set_xlim((0, xlim))
        ax[index, 1].set_xlim((0, xlim))
        ax[index, 0].set_ylim((-1, 1))
        ax[index, 0].legend()
    fig.suptitle("Analog state and control contribution evolution")
    ax[-1, 0].set_xlabel("$t / T$")
    ax[-1, 1].set_xlabel("$t / T$")
    fig.tight_layout()





.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_005.png
         :alt: Analog state vectors
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_005.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_006.png
         :alt: Analog state and control contribution evolution
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_006.png
         :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          | 0/16384 [00:00<?, ?it/s]      1%|1         | 205/16384 [00:00<00:07, 2044.40it/s]      3%|2         | 426/16384 [00:00<00:07, 2141.54it/s]      4%|3         | 652/16384 [00:00<00:07, 2191.43it/s]      5%|5         | 873/16384 [00:00<00:07, 2197.49it/s]      7%|6         | 1097/16384 [00:00<00:06, 2210.28it/s]      8%|8         | 1319/16384 [00:00<00:06, 2208.45it/s]      9%|9         | 1540/16384 [00:00<00:06, 2172.22it/s]     11%|#         | 1758/16384 [00:00<00:06, 2148.71it/s]     12%|#2        | 1973/16384 [00:00<00:06, 2129.67it/s]     13%|#3        | 2189/16384 [00:01<00:06, 2136.11it/s]     15%|#4        | 2403/16384 [00:01<00:06, 2130.63it/s]     16%|#5        | 2617/16384 [00:01<00:06, 2126.64it/s]     17%|#7        | 2833/16384 [00:01<00:06, 2134.86it/s]     19%|#8        | 3055/16384 [00:01<00:06, 2159.06it/s]     20%|##        | 3282/16384 [00:01<00:05, 2190.55it/s]     21%|##1       | 3502/16384 [00:01<00:05, 2155.42it/s]     23%|##2       | 3718/16384 [00:01<00:05, 2144.53it/s]     24%|##4       | 3933/16384 [00:01<00:05, 2133.84it/s]     25%|##5       | 4147/16384 [00:01<00:05, 2132.01it/s]     27%|##6       | 4371/16384 [00:02<00:05, 2160.96it/s]     28%|##8       | 4594/16384 [00:02<00:05, 2178.65it/s]     29%|##9       | 4818/16384 [00:02<00:05, 2193.78it/s]     31%|###       | 5042/16384 [00:02<00:05, 2205.90it/s]     32%|###2      | 5268/16384 [00:02<00:05, 2221.14it/s]     34%|###3      | 5491/16384 [00:02<00:04, 2216.53it/s]     35%|###4      | 5717/16384 [00:02<00:04, 2228.31it/s]     36%|###6      | 5941/16384 [00:02<00:04, 2229.93it/s]     38%|###7      | 6166/16384 [00:02<00:04, 2235.22it/s]     39%|###9      | 6391/16384 [00:02<00:04, 2237.98it/s]     40%|####      | 6618/16384 [00:03<00:04, 2245.42it/s]     42%|####1     | 6843/16384 [00:03<00:04, 2229.72it/s]     43%|####3     | 7067/16384 [00:03<00:04, 2226.77it/s]     44%|####4     | 7290/16384 [00:03<00:04, 2220.80it/s]     46%|####5     | 7514/16384 [00:03<00:03, 2223.99it/s]     47%|####7     | 7737/16384 [00:03<00:03, 2202.37it/s]     49%|####8     | 7958/16384 [00:03<00:03, 2182.28it/s]     50%|####9     | 8180/16384 [00:03<00:03, 2190.84it/s]     51%|#####1    | 8404/16384 [00:03<00:03, 2205.34it/s]     53%|#####2    | 8625/16384 [00:03<00:03, 2195.15it/s]     54%|#####4    | 8853/16384 [00:04<00:03, 2218.92it/s]     55%|#####5    | 9077/16384 [00:04<00:03, 2222.69it/s]     57%|#####6    | 9305/16384 [00:04<00:03, 2238.75it/s]     58%|#####8    | 9529/16384 [00:04<00:03, 2230.01it/s]     60%|#####9    | 9753/16384 [00:04<00:02, 2220.71it/s]     61%|######    | 9976/16384 [00:04<00:02, 2205.99it/s]     62%|######2   | 10198/16384 [00:04<00:02, 2208.24it/s]     64%|######3   | 10419/16384 [00:04<00:02, 2187.19it/s]     65%|######4   | 10644/16384 [00:04<00:02, 2205.73it/s]     66%|######6   | 10865/16384 [00:04<00:02, 2205.67it/s]     68%|######7   | 11091/16384 [00:05<00:02, 2218.97it/s]     69%|######9   | 11313/16384 [00:05<00:02, 2162.80it/s]     70%|#######   | 11533/16384 [00:05<00:02, 2172.24it/s]     72%|#######1  | 11753/16384 [00:05<00:02, 2179.60it/s]     73%|#######3  | 11977/16384 [00:05<00:02, 2196.93it/s]     74%|#######4  | 12204/16384 [00:05<00:01, 2217.88it/s]     76%|#######5  | 12435/16384 [00:05<00:01, 2244.34it/s]     77%|#######7  | 12662/16384 [00:05<00:01, 2251.46it/s]     79%|#######8  | 12892/16384 [00:05<00:01, 2264.63it/s]     80%|########  | 13119/16384 [00:05<00:01, 2254.61it/s]     81%|########1 | 13345/16384 [00:06<00:01, 2248.62it/s]     83%|########2 | 13571/16384 [00:06<00:01, 2250.03it/s]     84%|########4 | 13797/16384 [00:06<00:01, 2245.86it/s]     86%|########5 | 14024/16384 [00:06<00:01, 2251.06it/s]     87%|########6 | 14250/16384 [00:06<00:00, 2253.41it/s]     88%|########8 | 14479/16384 [00:06<00:00, 2263.69it/s]     90%|########9 | 14706/16384 [00:06<00:00, 2254.82it/s]     91%|#########1| 14932/16384 [00:06<00:00, 2252.26it/s]     93%|#########2| 15158/16384 [00:06<00:00, 2245.49it/s]     94%|#########3| 15389/16384 [00:06<00:00, 2264.23it/s]     95%|#########5| 15618/16384 [00:07<00:00, 2271.07it/s]     97%|#########6| 15847/16384 [00:07<00:00, 2274.47it/s]     98%|#########8| 16078/16384 [00:07<00:00, 2283.89it/s]    100%|#########9| 16307/16384 [00:07<00:00, 2276.43it/s]    100%|##########| 16384/16384 [00:07<00:00, 2211.10it/s]




.. GENERATED FROM PYTHON SOURCE LINES 262-265

Simulation
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 265-277

.. code-block:: default


    size = 1 << 14
    u_hat_ctsd = np.zeros(size)
    u_hat_leap_frog = np.zeros(size)

    for index in range(size):
        u_hat_ctsd[index] = next(digital_estimator_ctsd)
        u_hat_leap_frog[index] = next(digital_estimator_leap_frog)

    u_hat_ctsd = u_hat_ctsd[K1 + K2 :]
    u_hat_leap_frog = u_hat_leap_frog[K1 + K2 :]








.. GENERATED FROM PYTHON SOURCE LINES 278-281

Visualize Results
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 281-334

.. code-block:: default


    plt.rcParams["figure.figsize"] = [6.40 * 1.34, 6.40]

    f, psd = cbadc.utilities.compute_power_spectral_density(
        u_hat_ctsd[:],
        fs=1 / analog_frontend_ctsd.digital_control.clock.T,
        nperseg=u_hat_ctsd.size,
    )
    signal_index = cbadc.utilities.find_sinusoidal(psd, 15)
    noise_index = np.ones(psd.size, dtype=bool)
    noise_index[signal_index] = False
    noise_index[f < (BW * 1e-2)] = False
    noise_index[f > BW] = False
    fom = cbadc.utilities.snr_spectrum_computation_extended(
        psd, signal_index, noise_index, fs=1 / analog_frontend_ctsd.digital_control.clock.T
    )
    est_SNR = cbadc.fom.snr_to_dB(fom['snr'])
    est_ENOB = cbadc.fom.snr_to_enob(est_SNR)
    plt.semilogx(
        f,
        10 * np.log10(np.abs(psd)),
        label=f"CTSD, OSR={1/(2 * analog_frontend_ctsd.digital_control.clock.T * BW):.0f}, est_ENOB={est_ENOB:.1f} bits, est_SNR={est_SNR:.1f} dB",
    )

    f, psd = cbadc.utilities.compute_power_spectral_density(
        u_hat_leap_frog[:],
        fs=1 / analog_frontend_ctsd.digital_control.clock.T,
        nperseg=u_hat_leap_frog.size,
    )
    signal_index = cbadc.utilities.find_sinusoidal(psd, 15)
    noise_index = np.ones(psd.size, dtype=bool)
    noise_index[signal_index] = False
    noise_index[f < (BW * 1e-2)] = False
    noise_index[f > BW] = False
    fom = cbadc.utilities.snr_spectrum_computation_extended(
        psd, signal_index, noise_index, fs=1 / analog_frontend_ctsd.digital_control.clock.T
    )
    est_SNR = cbadc.fom.snr_to_dB(fom['snr'])
    est_ENOB = cbadc.fom.snr_to_enob(est_SNR)
    plt.semilogx(
        f,
        10 * np.log10(np.abs(psd)),
        label=f"LF, OSR={1/(2 * analog_frontend_ctsd.digital_control.clock.T * BW):.0f}, est_ENOB={est_ENOB:.1f} bits, est_SNR={est_SNR:.1f} dB",
    )

    plt.title("Power spectral density of input estimate")
    plt.xlabel('Hz')
    plt.ylabel('$V^2$ / Hz dB')
    plt.legend()
    plt.grid(which="both")
    plt.gcf().tight_layout()





.. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_007.png
   :alt: Power spectral density of input estimate
   :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_007.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 335-338

Time
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 338-350

.. code-block:: default


    t = np.arange(u_hat_ctsd.size)
    plt.plot(t, u_hat_ctsd, label="CTSD")
    plt.plot(t, u_hat_leap_frog, label="LF")
    plt.xlabel("$t / T$")
    plt.ylabel("$\hat{u}(t)$")
    plt.title("Estimated input signal")
    plt.grid()
    plt.xlim((0, 1500))
    plt.ylim((-1, 1))
    plt.legend()
    plt.tight_layout()



.. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_008.png
   :alt: Estimated input signal
   :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_008.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  48.213 seconds)


.. _sphx_glr_download_tutorials_b_high_level_simulation_plot_i_simulating_a_delta_sigma_modulator.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_i_simulating_a_delta_sigma_modulator.py <plot_i_simulating_a_delta_sigma_modulator.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_i_simulating_a_delta_sigma_modulator.ipynb <plot_i_simulating_a_delta_sigma_modulator.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
